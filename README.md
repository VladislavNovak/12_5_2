# Задание 2. Сортировка

## Что нужно сделать
Пользователь вводит в консоль 15 дробных чисел. 
Необходимо прочитать их и вывести в консоль в порядке от большего к меньшему. 
По возможности используйте минимум дополнительной памяти и проходов по массиву.

### Пример

Ввод: 1.2 2.3 1.11 3.4 5.5 5.4 5.3 5.1 1.5 1.25 5.41 5.31 5.11 1.51 1.251
Вывод: 5.5 5.41 5.4 5.31 5.3 5.11 5.1 3.4 2.3 1.51 1.5 1.251 1.25 1.2 1.11

# Об алгоритмах:

Сложность алгоритмов оценивают по времени выполнения и по используемой памяти.
Под временем понимается количество операций. 
Или, иначе говоря, количество тактов, которое выполняет процессор, прежде чем алгоритм закончится.

Таким образом, идея `big O` заключается в том, чтобы оценить, какое количество шагов нужно сделать, чтобы алгоритм закончил своё выполнение. 
`big O` показывает зависимость между входными данными (например, входящим массивом) и количеством операций, которые выполнит компьютер.

В О-нотации на операции с одной или двумя переменными вроде _i++_, _a * b_, _a / 1024_, _max(a,b)_ уходит всего одна единица времени.

При этом не учитываются константы.

`O`  - это принятое обозначение концепции.
`(n)` - в скобках указывается формула, которая описывает поведение алгоритма.

## `Линейная сложность`

Выражается формулой O(n).

Указывает, что количество шагов зависит от n. Чем больше n, тем большее количество шагов до завершения будет сделано:

```C++
int sum(int n) {
	if (n == 1) return 1;
	return (n + sum(n - 1))
}
```

Суть в данном случае в том, что если n == 10 то, совершится 10 тактов. Если же n == 1000, то произойдет тысяча тактов.

Такой сложностью обладает, например, поиск наибольшего элемента в неотсортированном массиве. 
Нужно пройтись по всем элементам массива, чтобы понять, какой из них наибольший.

Нужно помнить, что вариации типа `n + n` попадают в эту категорию сложности. Например, есть два последовательных цикла for:

```C++
void foo(int[] someArr) {
	int a, b;
	for (int item : someArr) a += item;
	for (int item : someArr) b += item;
}
```

Здесь можно сказать, что происходят `последовательные` действия. 
В этом случае сложность оценивается `сложение`. Т.е. как `O(n + n)`. В итоге это просто `O(n)`.

Рассмотрим такой пример:

```C++
void foo(int[] someArr) {
	int a;
	for (int i = 0; i < (someArr.size() / 2); ++i) {
		a += someArr[i];
	}
}
```

В данном случае мы складываем лишь половину массива. Это можно выразить формулой `O(n / 2)`. 
Что тоже укладывается в линейную сложность `O(n)`.

Линейный поиск работает с массивами любой сложности. Главным образом с неотсортированными.

## `Логарифмическая сложность`

Выражается формулой O(log n).

Если сформулировать, то это алгоритм, где на каждой итерации берётся лишь половина элементов.

Простейший пример — бинарный поиск. 
Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам. 
Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. 
Если же меньше, то наоборот — отбросим начальную половину. 
И так будем продолжать делить пополам, в итоге получим `log n` элементов.

Алгоритм на каждом шаге уменьшает проблему в два раза. 
Поэтому формула обозначается как логарифм (чаще всего подразумевается именно двоичный логарифм). 
Дело в том, что логарифм это степень, в которую нужно возвести основание, чтобы получить аргумент.

Например, представим, что в массиве из 32 отсортированных элементов нам нужно найти определенное значение. 
Договоримся заранее, что оно расположено на нулевой позиции в массиве, но мы этого как будто не знаем. 
Получается, что нужно разделить 32, потом 16, 8, 4, 2, 1. Получается log2(32) == 5

Здесь можно сказать, что на каждой итерации берется лишь половина элементов. 
В этом случае сложность оценивается `деление`. Т.е. как `O(log n)`.

Важно знать, что данный алгоритм включает в себя все возможные вариации типа `O(log(n) + n)` или `O(log(n) x n)`, 
потому что нас интересует лишь самый быстрорастущий компонент алгоритма.

Бинарный поиск работает с отсортированными массивами.

## `Квадратичная сложность`

Выражается формулой O(n^2).

Представляет из себя два вложенных цикла. Таким образом, количество операций будет зависеть от размера массива как `n * n`.

Характерный пример цикл в цикле:

```C++
void foo(int[] someArr) {
	for(int i = 0; i < someArr.size(); ++i) {
		for(int j = 0; j < someArr.size(); ++j) {
			print(someArr[i] + someArr[j])
		}
	}
}
```

Здесь можно сказать, что происходят `вложенные` действия. 
В этом случае сложность оценивается как `умножение`. Т.е. как `O(n x n)`.

Представим, что в массиве (т.е. в n) 4 элемента. Получается, что итерироваться будем 16 раз. 
В итоге формулой это можно представить просто как `O(n^2)`.

## `Список полезной литературы и видео`

* [Введение (видео)](https://www.youtube.com/watch?v=EeP-KHoEHVg)
* [Почитать после видео](https://skillbox.ru/media/code/big-o-notation-chto-eto-takoe-i-kak-eye-poschitat/)
* [BigO на примерах в JS](https://habr.com/ru/post/444594/)
* [Перечисление основных алгоритмов](https://upread.ru/art.php?id=659)
* [Описание с подробными примерами](https://habr.com/ru/post/335920/)







